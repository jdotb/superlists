[9/29/21]
________________
* I began this project a couple of weeks ago, but I didn't start at the beginning.  When I came back to it,
    I forgot where I left off, and didn't really remember what I was doing when I stopped...
    so I decided I'd just start over from the beginning and keep a much more methodical journal.


1. Project set-up and Django environment deployment.

2. Git setup and first commit.

3. User story created - functional_tests 'expected fails'

4. Unit Tests vs Functional Tests:
    _Functional tests_  tests the app's function from user's POV
    _Unit tests_        tests the application from the dev's POV

5. TDD approach thus far:
    a. Start by writing functional test that describes the new functionality from user's POV

    b. Once we have a FAILING functional test, begin to brainstorm how to write CODE to get it to PASS
        > now write unit tests to define how we want our code to behave.
        > each line of production code we write should be tested by (at least) one unit test

    c. Once we have FAILING unit test, write small amount of application code, just to get unit test to pass.

    d. Now rerun functional tests and see if they pass, or at least show progress towards passing.  Use info to guide
        next steps - either write new unit tests, then new code, etc.

6. TDD methodology requires small, incremental changes to code - after creating unit test under /lists/tests.py we ran
    python manage.py test to find an expected failure (which is the next best thing to a passing test).  Now that we
    have both a failing unit test and a failing functional test - the Testing Goat give his blessing to code away.

7. We have edited tests.py to look for 'home_page' then run test - ImportError: cannot import name 'home_page'

    So then, we went to views.py and added home_page = None, and reran the test...
        ERROR: django.urls.exceptions.Resolver404: {'path': '.'}
            * The test failure is telling us that we need a URL mapping (urls.py)
8. In urls.py we remove the admin, import views, and add (r'^$', views.home_page, name='home') and rerun the test
        PASS! - make commits

9.  Next, make changes to unit test by adding some checks (second test).

        TDD unit-test/code cycle:
            1. In terminal, run unit tests and see how they fail
            2. In the editor, make minimal code change to address the current test failure, rerun test.
            3. Repeat

10. Now run functional test and check output.  FAILED? But, it's just our reminder to finish.

        |TDD Principle|
       __* Whenever you leave the project to take a break, just rerun the last test to figure out where you left off *__

        > Our functional_test.py told us to 'Finish the test!', so we will.

11. Resuming functional_test.py, checks were added.

        |TDD Principle #2|
            __* Don't test constants.  Unit tests should test logic, flow control, and configuration *__

    * The hardcoded html in views.py isn't great, should use templates instead (aka refactor).
    a. Created directory called 'templates' under lists (lists/templates) - then created home.html
    b. Must add 'lists' to INSTALLED_APPS (superlists/superlists/settings.py)

12. After some test cleanup and refactoring the hardcoded html as a template, need to use Django's render_to_string
    function which will allow rendering of the home.html file as a string so that tests can be run.

    > Imported Django Test Client and used the built-in 'assertTemplateUsed'

    > Instead of manually creating an HttpRequest object and calling the view function directly, use self.client.get('URL')

    > Remove old test_root_url_resolves since this is tested by Django Test Client

    __* TIP (refactoring): When refactoring, work on either the code or the tests, but not both at once *__
        * (It's also a good idea to commit after a refactor)

13. With unit test passing, we need to address the failing functional_test.py

    Need to add:
        a. <h1> (then test)
        b. input element with id="id_new_item" and placeholder text (then test)
        c. table "id_list_table" (then test)

    * The remaining failure is vague, added a failure message to the assertTrue method

    COMMIT

14. Note:
        >> Functional tests are the ultimate judge of whether your app works or not <<
        >> Unit tests are a tool to help you along the way <<

15. Saving user data
        > A form needs to be added with a POST method, add it and test.
        > Failure - returned 'forbidden' due to no CSRF token - add with {% csrf_token %}
        > rerunning functional_tests.py gives us the expected failure.
        > Still need to config an action= attribute in the form, and setup view to handle POSTs
        > Add POST submission to table
        > {{ ... }} includes python object as string

        Note: unit-test/code cycle sometimes known as Red, Green, Refactor
            - Write failing test (red)
            - Write simple code to get it to pass (Green, even if you have to 'cheat')
            - Refactor

        > See EDIT 1 in functional_test.py (ln 44)
        > still failing... so we have to cheat by adding the 1 manually (will revisit this issue later)

        <tr><td>1:  {{ new_item_text }}</td></tr>
                ^
    > wrapping up, we see our self.fail('Finish the test!')

16. Return to fix our 'cheat'
    > Added tests to check our form data and elements, but we're still failing (still cheating)
    > Follow the DRY (don't repeat yourself) and 3 strikes and refactor principles.
        > Three occurrences of code block begets a refactor
        > before refactor, COMMIT

    > Need to fix the issue of only being able to handle 1 list item in table
    > In functional test, we can write a helper function and not worry about test execution because only
        functions that begin with test will be executed
    > Created helper function to CHECK the list items, but they aren't persisting yet, but the test works.

    > after refactor, COMMIT!
