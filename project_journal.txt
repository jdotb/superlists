[9/29/21]
________________

1. Project set-up and Django environment deployment.

2. Git setup and first commit.

3. User story created - functional_tests 'expected fails'

4. Unit Tests vs Functional Tests:
    Functional tests: tests the app's function from user's POV
    Unit tests: tests the application from the dev's POV

5. TDD approach thus far:
    a. Start by writing functional test that describes the new functionality from user's POV

    b. Once we have a FAILING functional test, begin to brainstorm how to write CODE to get it to PASS
        - now write unit tests to define how we want our code to behave.
        - each line of production code we write should be tested by (at least) one unit test

    c. Once we have FAILING unit test, write small amount of application code, just to get unit test to pass.

    d. Now rerun functional tests and see if they pass, or at least show progress towards passing.  Use info to guide
        next steps - either write new unit tests, then new code, etc.

6. TDD methodology requires small, incremental changes to code - after creating unit test under /lists/tests.py we ran
    python manage.py test to find an expected failure (which is the next best thing to a passing test).  Now that we
    have both a failing unit test and a failing functional test - the Testing Goat give his blessing to code away.

7. We have edited tests.py to look for 'home_page' then run test - ImportError: cannot import name 'home_page'

    So then, we went to views.py and added home_page = None, and reran the test...
        ERROR: django.urls.exceptions.Resolver404: {'path': '.'}
            * The test failure is telling us that we need a URL mapping (urls.py)
8. In urls.py we remove the admin, import views, and add (r'^$', views.home_page, name='home') and rerun the test
        PASS! - make commits

9.  Next, make changes to unit test by adding some checks (second test).

        TDD unit-test/code cycle:
            1. In terminal, run unit tests and see how they fail
            2. In the editor, make minimal code change to address the current test failure, rerun test.
            3. Repeat

10. Now run functional test and check output.  FAILED? But, it's just our reminder to finish.
        TDD Principle:
            _ Whenever you leave the project to take a break, just rerun the last test to figure out where you left off _
    Our functional_test.py told us to 'Finish the test!', so we will.

11. Resuming functional_test.py, checks were added.
        TDD Principle #2:
            _ Don't test constants.  Unit tests should test logic, flow control, and configuration _

    * The hardcoded html in views.py isn't great, should use templates instead (aka refactor).
    a. Created directory called 'templates' under lists (lists/templates) - then created home.html
    b. Must add 'lists' to INSTALLED_APPS (superlists/superlists/settings.py)

12. After some test cleanup and refactoring the hardcoded html as a template, need to use Django's render_to_string
    function which will allow rendering of the home.html file as a string so that tests can be run.

    Imported Django Test Client and used the built in 'assertTemplateUsed'

    Instead of manually creating an HttpRequest object and calling the view function directly, use self.client.get('URL')

    Remove old test_root_url_resolves since this is tested by Django Test Client

    _ TIP (refactoring): When refactoring, work on either the code or the tests, but not both at once _
    * It's also a good idea to commit after a refactor